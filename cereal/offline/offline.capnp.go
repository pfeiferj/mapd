// Code generated by capnpc-go. DO NOT EDIT.

package offline

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Way capnp.Struct

// Way_TypeID is the unique identifier for the type Way.
const Way_TypeID = 0xa4b9c59286b69600

func NewWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 80, PointerCount: 5})
	return Way(st), err
}

func NewRootWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 80, PointerCount: 5})
	return Way(st), err
}

func ReadRootWay(msg *capnp.Message) (Way, error) {
	root, err := msg.Root()
	return Way(root.Struct()), err
}

func (s Way) String() string {
	str, _ := text.Marshal(0xa4b9c59286b69600, capnp.Struct(s))
	return str
}

func (s Way) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Way) DecodeFromPtr(p capnp.Ptr) Way {
	return Way(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Way) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Way) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Way) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Way) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Way) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Way) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Way) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Way) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Way) Ref() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Way) HasRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Way) RefBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Way) SetRef(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Way) MaxSpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Way) SetMaxSpeed(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Way) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Way) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Way) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Way) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Way) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Way) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Way) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Way) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Way) Nodes() (Coordinates_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Coordinates_List(p.List()), err
}

func (s Way) HasNodes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Way) SetNodes(v Coordinates_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNodes sets the nodes field to a newly
// allocated Coordinates_List, preferring placement in s's segment.
func (s Way) NewNodes(n int32) (Coordinates_List, error) {
	l, err := NewCoordinates_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Coordinates_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Way) Lanes() uint8 {
	return capnp.Struct(s).Uint8(40)
}

func (s Way) SetLanes(v uint8) {
	capnp.Struct(s).SetUint8(40, v)
}

func (s Way) AdvisorySpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(48))
}

func (s Way) SetAdvisorySpeed(v float64) {
	capnp.Struct(s).SetUint64(48, math.Float64bits(v))
}

func (s Way) Hazard() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Way) HasHazard() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Way) HazardBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Way) SetHazard(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Way) OneWay() bool {
	return capnp.Struct(s).Bit(328)
}

func (s Way) SetOneWay(v bool) {
	capnp.Struct(s).SetBit(328, v)
}

func (s Way) MaxSpeedForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(56))
}

func (s Way) SetMaxSpeedForward(v float64) {
	capnp.Struct(s).SetUint64(56, math.Float64bits(v))
}

func (s Way) MaxSpeedBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(64))
}

func (s Way) SetMaxSpeedBackward(v float64) {
	capnp.Struct(s).SetUint64(64, math.Float64bits(v))
}

func (s Way) Id() int64 {
	return int64(capnp.Struct(s).Uint64(72))
}

func (s Way) SetId(v int64) {
	capnp.Struct(s).SetUint64(72, uint64(v))
}

func (s Way) SpecialNodes() (Node_List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return Node_List(p.List()), err
}

func (s Way) HasSpecialNodes() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Way) SetSpecialNodes(v Node_List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewSpecialNodes sets the specialNodes field to a newly
// allocated Node_List, preferring placement in s's segment.
func (s Way) NewSpecialNodes(n int32) (Node_List, error) {
	l, err := NewNode_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Node_List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Way_List is a list of Way.
type Way_List = capnp.StructList[Way]

// NewWay creates a new list of Way.
func NewWay_List(s *capnp.Segment, sz int32) (Way_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 80, PointerCount: 5}, sz)
	return capnp.StructList[Way](l), err
}

// Way_Future is a wrapper for a Way promised by a client call.
type Way_Future struct{ *capnp.Future }

func (f Way_Future) Struct() (Way, error) {
	p, err := f.Future.Ptr()
	return Way(p.Struct()), err
}

type Coordinates capnp.Struct

// Coordinates_TypeID is the unique identifier for the type Coordinates.
const Coordinates_TypeID = 0x922b57c60c6a46d1

func NewCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func NewRootCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func ReadRootCoordinates(msg *capnp.Message) (Coordinates, error) {
	root, err := msg.Root()
	return Coordinates(root.Struct()), err
}

func (s Coordinates) String() string {
	str, _ := text.Marshal(0x922b57c60c6a46d1, capnp.Struct(s))
	return str
}

func (s Coordinates) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coordinates) DecodeFromPtr(p capnp.Ptr) Coordinates {
	return Coordinates(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coordinates) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Coordinates) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coordinates) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coordinates) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coordinates) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Coordinates) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Coordinates) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Coordinates) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Coordinates_List is a list of Coordinates.
type Coordinates_List = capnp.StructList[Coordinates]

// NewCoordinates creates a new list of Coordinates.
func NewCoordinates_List(s *capnp.Segment, sz int32) (Coordinates_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Coordinates](l), err
}

// Coordinates_Future is a wrapper for a Coordinates promised by a client call.
type Coordinates_Future struct{ *capnp.Future }

func (f Coordinates_Future) Struct() (Coordinates, error) {
	p, err := f.Future.Ptr()
	return Coordinates(p.Struct()), err
}

type Offline capnp.Struct

// Offline_TypeID is the unique identifier for the type Offline.
const Offline_TypeID = 0xcb5ff253617678e0

func NewOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func NewRootOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func ReadRootOffline(msg *capnp.Message) (Offline, error) {
	root, err := msg.Root()
	return Offline(root.Struct()), err
}

func (s Offline) String() string {
	str, _ := text.Marshal(0xcb5ff253617678e0, capnp.Struct(s))
	return str
}

func (s Offline) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Offline) DecodeFromPtr(p capnp.Ptr) Offline {
	return Offline(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Offline) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Offline) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Offline) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Offline) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Offline) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Offline) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Offline) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Offline) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Offline) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Offline) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Offline) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Offline) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Offline) Ways() (Way_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Way_List(p.List()), err
}

func (s Offline) HasWays() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Offline) SetWays(v Way_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewWays sets the ways field to a newly
// allocated Way_List, preferring placement in s's segment.
func (s Offline) NewWays(n int32) (Way_List, error) {
	l, err := NewWay_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Way_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Offline) Overlap() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Offline) SetOverlap(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

// Offline_List is a list of Offline.
type Offline_List = capnp.StructList[Offline]

// NewOffline creates a new list of Offline.
func NewOffline_List(s *capnp.Segment, sz int32) (Offline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return capnp.StructList[Offline](l), err
}

// Offline_Future is a wrapper for a Offline promised by a client call.
type Offline_Future struct{ *capnp.Future }

func (f Offline_Future) Struct() (Offline, error) {
	p, err := f.Future.Ptr()
	return Offline(p.Struct()), err
}

type NodeType uint16

// NodeType_TypeID is the unique identifier for the type NodeType.
const NodeType_TypeID = 0xdb6107251569f79c

// Values of NodeType.
const (
	NodeType_unknown      NodeType = 0
	NodeType_trafficLight NodeType = 1
	NodeType_stopSign     NodeType = 2
	NodeType_crosswalk    NodeType = 3
	NodeType_speedBump    NodeType = 4
)

// String returns the enum's constant name.
func (c NodeType) String() string {
	switch c {
	case NodeType_unknown:
		return "unknown"
	case NodeType_trafficLight:
		return "trafficLight"
	case NodeType_stopSign:
		return "stopSign"
	case NodeType_crosswalk:
		return "crosswalk"
	case NodeType_speedBump:
		return "speedBump"

	default:
		return ""
	}
}

// NodeTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func NodeTypeFromString(c string) NodeType {
	switch c {
	case "unknown":
		return NodeType_unknown
	case "trafficLight":
		return NodeType_trafficLight
	case "stopSign":
		return NodeType_stopSign
	case "crosswalk":
		return NodeType_crosswalk
	case "speedBump":
		return NodeType_speedBump

	default:
		return 0
	}
}

type NodeType_List = capnp.EnumList[NodeType]

func NewNodeType_List(s *capnp.Segment, sz int32) (NodeType_List, error) {
	return capnp.NewEnumList[NodeType](s, sz)
}

type Node capnp.Struct

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xc08b5b0529af185b

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Node(st), err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Node(st), err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.Root()
	return Node(root.Struct()), err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xc08b5b0529af185b, capnp.Struct(s))
	return str
}

func (s Node) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node) DecodeFromPtr(p capnp.Ptr) Node {
	return Node(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node) Type() NodeType {
	return NodeType(capnp.Struct(s).Uint16(0))
}

func (s Node) SetType(v NodeType) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Node) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Node) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Node) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Node) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// Node_List is a list of Node.
type Node_List = capnp.StructList[Node]

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[Node](l), err
}

// Node_Future is a wrapper for a Node promised by a client call.
type Node_Future struct{ *capnp.Future }

func (f Node_Future) Struct() (Node, error) {
	p, err := f.Future.Ptr()
	return Node(p.Struct()), err
}

const schema_da3a0d9284ca402f = "x\xda\xac\x94_h\x1cU\x14\xc6\xbf\xef\xde\xd9\xdd4" +
	"\xd9t;\xce\x08E(A\xb1\xd0Fk\x9aF_\x82" +
	"\xd0\x10\xb1\xd4\x10b&S\xc8C\x05\xb9\xec\xce\xa6\x9b" +
	"lf\x96\xdd\xcd\x9f\x15$ \xfe\xa1\x8a/AD\xa1" +
	"B\x85\x08\x0a\x85\xea\x83\x92B\x85\x08\xa9T\xad`\xc0" +
	"'E\xa8\x0f\x85\x16\xfa\xa0b\xb0\x05q\xe4\xcc\x92\xdd" +
	"\x8d\x08\x0a\xfa4s\x7f\xe7\xcc\xb9\xdf\xdcs\xbe{t" +
	"R\x8dX\x83\xbd}\x1a\xca{0\x95\x8e\xb7N\xccf" +
	"?\x9f~h\x15\xde\x01\xaax`\xe4\xcb\x17W{\x87" +
	"\xbf\x83\x95\x01\x86\x168F\xe7,3\x80\xf3\x12\x97\xc0" +
	"?\xde\xfc\xe4\xe5\xd5+\x97\xd6\xbc\x03\xecn\xa7\xa6R" +
	"\x92{\x8b\xddt\xeeJ\xee\xd06_\xd1`|z\xff" +
	"\xc5\xc3\xa9\xd3\xafmHe\xfd\x97\xca[\xa9{\xe8\xfc" +
	"(\x1f:?\xa4.\x82\xf1\xf5\xe5E\xe3\xff\xf2\xecW" +
	"\x92\x9c\xea\xa8\x9d\x14|>\xddO\xe7\xf5\xb4\xbc\x9eM" +
	"O\x13\x8c\xcf\xfdV\xba\xf7`\xc6|\x0f\xfb@\x87h" +
	"p\xe8F\xe6\x18\x9d\xed\x8c\x14\xfe9\xb3\x82#q>" +
	"\xa8\x06\xa6<\x10Y\xc5b\xb9\x14\x06\x03Q\xf3\xf9H" +
	"\xdeT\xc2\xca\xf0\x13QT-\x94BS\x0fj\xc0$" +
	"\xe9ui\x0b\xb0\x08\xd8\x87\xc7\x00\xef\x90\xa6\xf7\xa8\xa2" +
	"M\xba\x1488\x05xG5\xbd\xc7\x15\xe3\xb2\xa9\x97" +
	"\xea\x0b\x85\x00\x00{\xa0\xd8\x03\xc6\xe5(\x9c\x11\x08\x06" +
	"-\xb6#A\xff\xad\x84i\xd3hn=\xb2\xb3\xb5\xf3" +
	"\x11\xfb\x01\xff\x025\xfdu\xb6ww>\xe6\x03\x80\xff" +
	"\xa1\xf0\xcbT\xa4r\xa9\x00\xe7\x12\xc7\x00\x7f]\xf0\xa6" +
	"\xa4k\xba\xd4\x80\xf3\x19\x87\x01\xff\xb2\xf0\xab\xc2-\xe5" +
	"\xd2\x02\x9c+\x09\xdf\x10~MxJ\xbbL\x01\xce\x17" +
	"\x09\xdf\x14\xfe\x8d\xf0\xb4\xe52\x0d8_'\xfc\xaa\xf0" +
	"o\x85g\x94\x9b\xcc\xc4\x16\x8f\x01\xfe5\xe17\x85w" +
	"\x1dr\xd9\x0587\x12~]\xf8m\xe1{\xd2.\xf7" +
	"\x00\xce-V\x01\xff\xa6\xf0_\x85wk\x97\xdd\xd2\xa8" +
	"\xa4\xfem\xe1w\xa88\xd8s\x92.{\x00g;\x09" +
	"\xfc$\x81\xdf\xe5\x83l\xc6e\x16p\xee\xf2\x05\xc0\xbf" +
	"#\xdcR\x8avo\x97\xcb^\xc0\xa1z\x15\xf0-\xa5" +
	"\xe9\xef\x13\xbew\x8f\xcb\xbd\x80\xd3\xab\xee\x03\xfc.\xe1" +
	"\xae\xf0\x9c\xe52\x078\xb6\x9a\x05\xfc}\xc2\x1fV\x8a" +
	"\xb9\xd0\xcc\x07\xccB1\x0bf\xaaAq\xe7=\x9e7" +
	"\xcb~%\x08\x0a\x1d\x9d>>_\x0a\xc7M}\xd72" +
	"\x0a\xdbK\xb3\xbc+j\x96;\xa2}aT\x08j\xdc" +
	"\x0bNjr_\xdb\x83\xa0\xc0\xbe\xb2\x09\x83\x1a\xd3P" +
	"L\x83\xb1),\x96jQ\xb5\x81\xbeDC\xab\xe6\x19" +
	"\xf3\x9c\xa9\x16v4\x1e\x8f\xc2`\xda4H(\xb2C" +
	"2OD\xd5%S-\xb4G\xb4\x15\x195\xf9\xb9$" +
	"\xd4\x8a\xe9R\x81)(\xa6\xc0\xb8V\x09\xf2%S\x9e" +
	"@n\xb7\xd8\x96\xad\x9bb\xffa\xba'\xa2\x02\x03\x99" +
	"\xeel\xcbXO\xf6\x03\xde\x88\xa67\xdea\xac\xa7\xc4" +
	"m'5\xbdS\x8a\xb6j\x0e\xb6\xed\x89\xdb&5\xbd" +
	"g\x14s\xf5F%`\xae\xed|\x909\xfc_&|" +
	"\xbaX\xcc\xc9R\x94\xeeo)}{\x18\xf0\xde\xd0\xf4" +
	"\xcew(}G\xe0[\x9a\xdeZ\x87\xd2w\x05\x9e\xd3" +
	"\xf4\xde\x17\xff\xe9\xc4\x7f\xf6{\x02\xcfkz\x17\x14i" +
	"%\xde\xb3?\x90\x9f_\xd3\xf46\xc4xVb<\xfb" +
	"\xd3Q\xc0[\xd7\xf46\xd5\x7f\x9a\xab\xdc\x92i\xb4;" +
	"\xb5s[7\xfb\xb4\x12-\x06\xd5\xb2\xa9\xfc\xcb\x03\x99" +
	"\x88\x0a}\xc1\xa9F%9\x91\xe6?>6*gn" +
	"\x1f\x99\x05\xa8\x92\xeb\x91\xda>8\x05\xd0\xb2\xef\x9f\x02" +
	"V\x16\xc2\xb90Z\x0a\xe3z\xd5\x14\x8b\xa5\xfc8r" +
	"\xa5\x993\xf5\xb8V\x8f*~i&\x04\x10\xe7\xabQ" +
	"\xad\xb6d\xca\xe0\x9c\x0cXP\x18]\x98\x07+\x7f\x06" +
	"\x00\x00\xff\xff\xf4\xf8lR"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da3a0d9284ca402f,
		Nodes: []uint64{
			0x922b57c60c6a46d1,
			0xa4b9c59286b69600,
			0xc08b5b0529af185b,
			0xcb5ff253617678e0,
			0xdb6107251569f79c,
		},
		Compressed: true,
	})
}
