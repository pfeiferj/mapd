// Code generated by capnpc-go. DO NOT EDIT.

package main

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Way capnp.Struct

// Way_TypeID is the unique identifier for the type Way.
const Way_TypeID = 0xa4b9c59286b69600

func NewWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 72, PointerCount: 4})
	return Way(st), err
}

func NewRootWay(s *capnp.Segment) (Way, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 72, PointerCount: 4})
	return Way(st), err
}

func ReadRootWay(msg *capnp.Message) (Way, error) {
	root, err := msg.Root()
	return Way(root.Struct()), err
}

func (s Way) String() string {
	str, _ := text.Marshal(0xa4b9c59286b69600, capnp.Struct(s))
	return str
}

func (s Way) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Way) DecodeFromPtr(p capnp.Ptr) Way {
	return Way(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Way) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Way) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Way) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Way) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Way) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Way) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Way) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Way) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Way) Ref() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Way) HasRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Way) RefBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Way) SetRef(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Way) MaxSpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Way) SetMaxSpeed(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Way) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Way) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Way) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Way) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Way) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Way) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Way) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Way) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Way) Nodes() (Coordinates_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Coordinates_List(p.List()), err
}

func (s Way) HasNodes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Way) SetNodes(v Coordinates_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNodes sets the nodes field to a newly
// allocated Coordinates_List, preferring placement in s's segment.
func (s Way) NewNodes(n int32) (Coordinates_List, error) {
	l, err := NewCoordinates_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Coordinates_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Way) Lanes() uint8 {
	return capnp.Struct(s).Uint8(40)
}

func (s Way) SetLanes(v uint8) {
	capnp.Struct(s).SetUint8(40, v)
}

func (s Way) AdvisorySpeed() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(48))
}

func (s Way) SetAdvisorySpeed(v float64) {
	capnp.Struct(s).SetUint64(48, math.Float64bits(v))
}

func (s Way) Hazard() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Way) HasHazard() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Way) HazardBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Way) SetHazard(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Way) OneWay() bool {
	return capnp.Struct(s).Bit(328)
}

func (s Way) SetOneWay(v bool) {
	capnp.Struct(s).SetBit(328, v)
}

func (s Way) MaxSpeedForward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(56))
}

func (s Way) SetMaxSpeedForward(v float64) {
	capnp.Struct(s).SetUint64(56, math.Float64bits(v))
}

func (s Way) MaxSpeedBackward() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(64))
}

func (s Way) SetMaxSpeedBackward(v float64) {
	capnp.Struct(s).SetUint64(64, math.Float64bits(v))
}

// Way_List is a list of Way.
type Way_List = capnp.StructList[Way]

// NewWay creates a new list of Way.
func NewWay_List(s *capnp.Segment, sz int32) (Way_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 72, PointerCount: 4}, sz)
	return capnp.StructList[Way](l), err
}

// Way_Future is a wrapper for a Way promised by a client call.
type Way_Future struct{ *capnp.Future }

func (f Way_Future) Struct() (Way, error) {
	p, err := f.Future.Ptr()
	return Way(p.Struct()), err
}

type Coordinates capnp.Struct

// Coordinates_TypeID is the unique identifier for the type Coordinates.
const Coordinates_TypeID = 0x922b57c60c6a46d1

func NewCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func NewRootCoordinates(s *capnp.Segment) (Coordinates, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Coordinates(st), err
}

func ReadRootCoordinates(msg *capnp.Message) (Coordinates, error) {
	root, err := msg.Root()
	return Coordinates(root.Struct()), err
}

func (s Coordinates) String() string {
	str, _ := text.Marshal(0x922b57c60c6a46d1, capnp.Struct(s))
	return str
}

func (s Coordinates) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Coordinates) DecodeFromPtr(p capnp.Ptr) Coordinates {
	return Coordinates(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Coordinates) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Coordinates) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Coordinates) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Coordinates) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Coordinates) Latitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Coordinates) SetLatitude(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Coordinates) Longitude() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Coordinates) SetLongitude(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Coordinates_List is a list of Coordinates.
type Coordinates_List = capnp.StructList[Coordinates]

// NewCoordinates creates a new list of Coordinates.
func NewCoordinates_List(s *capnp.Segment, sz int32) (Coordinates_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Coordinates](l), err
}

// Coordinates_Future is a wrapper for a Coordinates promised by a client call.
type Coordinates_Future struct{ *capnp.Future }

func (f Coordinates_Future) Struct() (Coordinates, error) {
	p, err := f.Future.Ptr()
	return Coordinates(p.Struct()), err
}

type Offline capnp.Struct

// Offline_TypeID is the unique identifier for the type Offline.
const Offline_TypeID = 0xcb5ff253617678e0

func NewOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func NewRootOffline(s *capnp.Segment) (Offline, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return Offline(st), err
}

func ReadRootOffline(msg *capnp.Message) (Offline, error) {
	root, err := msg.Root()
	return Offline(root.Struct()), err
}

func (s Offline) String() string {
	str, _ := text.Marshal(0xcb5ff253617678e0, capnp.Struct(s))
	return str
}

func (s Offline) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Offline) DecodeFromPtr(p capnp.Ptr) Offline {
	return Offline(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Offline) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Offline) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Offline) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Offline) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Offline) MinLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Offline) SetMinLat(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Offline) MinLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Offline) SetMinLon(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Offline) MaxLat() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Offline) SetMaxLat(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Offline) MaxLon() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Offline) SetMaxLon(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Offline) Ways() (Way_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Way_List(p.List()), err
}

func (s Offline) HasWays() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Offline) SetWays(v Way_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewWays sets the ways field to a newly
// allocated Way_List, preferring placement in s's segment.
func (s Offline) NewWays(n int32) (Way_List, error) {
	l, err := NewWay_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Way_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Offline) Overlap() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Offline) SetOverlap(v float64) {
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

// Offline_List is a list of Offline.
type Offline_List = capnp.StructList[Offline]

// NewOffline creates a new list of Offline.
func NewOffline_List(s *capnp.Segment, sz int32) (Offline_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return capnp.StructList[Offline](l), err
}

// Offline_Future is a wrapper for a Offline promised by a client call.
type Offline_Future struct{ *capnp.Future }

func (f Offline_Future) Struct() (Offline, error) {
	p, err := f.Future.Ptr()
	return Offline(p.Struct()), err
}

const schema_da3a0d9284ca402f = "x\xda\xa4\xd4\xdf\x8b\x1bU\x14\x07\xf0\xef\xf7\xde\xc9\x8f" +
	"m\x92\xad\xe1\x0e\xe8\x83\x12\x10\x84\xb6\xa2v\xad\x0f\x12" +
	"\x84\x96\x0aE\x8a`\xaf\xf3\x90G\xb94\x13\x8dfg" +
	"\xc2$\xee&\x82Xe\x11\x95\x16\xda\xb0J\x0b\x15*" +
	"\xacPA\xa1J\x91\x16\xba\xb0\xc2*\xa8\xfb\xa2O\"" +
	"\x08\xfa\xe0?\xe0\x1f\xe0\xc8\xb9K~\xec\x83O}\x9b" +
	"\xf9\x9c3\xf7\\N\xbe\xe4\xf8=\x9e\x0aVj\xa9\x82" +
	"\xb2\x0f\x17\x8a\xf9/g^\xaf\xfe\xd0z|\x02\xbbL" +
	"\x95?u\xea\xa7\x8dI\xad\xf9;\x82\x12`\x1e\xe1\xaf" +
	"\xe6(\xe5\xe91\xae\x83\xff~\xf2\xed\xfb\x93\xef\xefn" +
	"\xd9e.\xcd;\x0b\xbe\xf5CN\xcc\x15i=q\x89" +
	"\x0fj0\xffs\xb4\xe6\xa2\x7f^\xf9Y\xce-,t" +
	"\xfb\xe3\xfe\x08\xbe1\x7f\xcbw'\xfe\x0aZ\xc4\x13y" +
	"\xda\xe9\xf4\xbaI\xfc\xa4:\xef\xfaI\xbf\xf9|\x9af" +
	"\xedn\xe2\x861\x07\xe7H[\xd6\x01\x10\x10\xa8\x1f=" +
	"\x0b\xd8#\x9a\xf6\x19\xc5:\x19Rp\xe5e\xc0\x1e\xd7" +
	"\xb4\xcf)\xe6=7\xec\x0e\xdfl\xc7\x00X\x81b\x05" +
	"\xcc{i\xf2\xaa \x18\xcfl:\x92\xfb#[\x8ec" +
	"\x19\xf5\xect\x94\x19\xf3\x18\x10\x0d\xa9\x19]\xe0|\x9a" +
	"y\x9b\x8f\x02\xd1H|\x83\x8aT!\x15`\xde\xe5Y" +
	" \xba |Q\xda5Cj\xbf\x99&\x10m\x88_" +
	"\x16\x0fT\xc8\x000\x97\xbc\x7f \xbe)^\xd0!\x0b" +
	"\x80\xb9\xe2\xfd\xa2\xf8U\xf1b\x10\xb2\x08\x98\x8f\xbd_" +
	"\x16\xbf.^R\xa1\xdf\xe55>\x0dD\x9b\xe2\xb7\xc4" +
	"\xcbGB\x96\x01\xf3\x95\xf7\x9b\xe2\xb7\xc5\x97\x8a!\x97" +
	"\x00\xf353 \xba%~O\xfc\x90\x0ey\x080w" +
	"\xfd\xf9\xb7\xc5w\xa8\xb8Ry\x81!+\x80\xd9\xf6\x85" +
	";R\xd8\x95\x0f\xaa\xa5\x90U\xc0|\xc7\xf7\x80hG" +
	"|O\xbcV\x0eY\x03\xcc\x8f\xfc\x08\x88\xf6\xc4\x7f\xa3" +
	"\xe2\xe1\xc4\xad\xc6\xacB\xb1\x0a\x96\xb2\xb83}\xceW" +
	"\xdd(\xea\xc7q{\xe1\x97:\xb9\xdaM^t\xc3\x03" +
	"\xafi2\x7fu\xa3\x03U7Z\xa86\x92\xb4\x1d\x0f" +
	"\xb8\x0c\x9e\xd3\xe4\x03\xf3d\x83\x82\x8d\x9eK\xe2\x01\x8b" +
	"P,\x82\xb9k\xafu\x07i6F\xc3\xdfav\xe6" +
	"k\xee-\x97\xb5\xa7w<\x99&q\xcb\x8dI(r" +
	"\xe1\xca<\x93f\xeb.k\xcf#6\xab\x9cv\xe7\xdf" +
	"\xf0%\xfc_\xd4^\xea4\xfc\xbb\xc4\xed\xa1Y\xb2\xaf" +
	"5\x01\xbb\xa9io,$\xfbS\xc1\xab\x9avK\xb1" +
	"\xae\xf6\x93V\xffL\xf0\xba\xa6\xbd)1\xd3>f\xf5" +
	"\xcf\x05oh\xda/\x15\x19\xf8\x88\xd5\xbf8\x06\xd8-" +
	"M\xbb#\xf9\x0a|\xbe\xea\xdb\xa7\x01{G\xd3\xee\xaa" +
	"\xfbZ\xf7\xe1u7\x9eo{\xfa\xdf\xb0\xbf\xebw\xd2" +
	"\xb58\xeb\xb9\xfe\xb4\xf7\xbf\x00\x00\x00\xff\xff\x06m\xdf" +
	"\xda"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da3a0d9284ca402f,
		Nodes: []uint64{
			0x922b57c60c6a46d1,
			0xa4b9c59286b69600,
			0xcb5ff253617678e0,
		},
		Compressed: true,
	})
}
